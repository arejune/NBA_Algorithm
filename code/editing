import pandas as pd
import numpy as np
import re
import requests
import os
import json
from datetime import datetime
from bs4 import BeautifulSoup
from scipy import stats
from io import StringIO

# Create directories for storing data
DATA_DIR = "playoff_data"
BETTING_HISTORY_DIR = os.path.join(DATA_DIR, "betting_history")

# Ensure directories exist
os.makedirs(DATA_DIR, exist_ok=True)
os.makedirs(BETTING_HISTORY_DIR, exist_ok=True)

def get_player_data_filename(first_name, last_name):
    """Generate a standardized filename for player data."""
    return os.path.join(DATA_DIR, f"{first_name.lower()}_{last_name.lower()}_playoff_data.pkl")

def get_player_betting_history_filename(first_name, last_name):
    """Generate a standardized filename for player betting history."""
    return os.path.join(BETTING_HISTORY_DIR, f"{first_name.lower()}_{last_name.lower()}_betting_history.json")

def check_existing_data(first_name, last_name):
    """Check if we already have data for this player and load it if available."""
    filename = get_player_data_filename(first_name, last_name)
    if os.path.exists(filename):
        try:
            return pd.read_pickle(filename)
        except Exception as e:
            print(f"Error loading existing data: {e}")
    return None

def save_player_data(first_name, last_name, playoff_data):
    """Save player data to file for future use."""
    if playoff_data is not None and not playoff_data.empty:
        filename = get_player_data_filename(first_name, last_name)
        try:
            playoff_data.to_pickle(filename)
            print(f"Player data saved to {filename}")
            return True
        except Exception as e:
            print(f"Error saving player data: {e}")
    return False

def load_betting_history(first_name, last_name):
    """Load previous betting predictions for this player."""
    filename = get_player_betting_history_filename(first_name, last_name)
    if os.path.exists(filename):
        try:
            with open(filename, 'r') as f:
                return json.load(f)
        except Exception as e:
            print(f"Error loading betting history: {e}")
    return []

def save_betting_prediction(first_name, last_name, team_abbr, results):
    """Save current betting predictions to history file."""
    if not results:
        return False
        
    filename = get_player_betting_history_filename(first_name, last_name)
    history = load_betting_history(first_name, last_name)
    
    # Create new prediction entry
    prediction = {
        "date": datetime.now().strftime("%Y-%m-%d"),
        "opponent": team_abbr,
        "lines": [],
        "outcome_recorded": False
    }
    
    for result in results:
        prediction["lines"].append({
            "stat": result["Stat"],
            "line": result["Line"],
            "probability": result["Probability"],
            "recommendation": result["Recommendation"],
            "actual_result": None  # To be filled in later
        })
    
    history.append(prediction)
    
    try:
        with open(filename, 'w') as f:
            json.dump(history, f, indent=2)
        print(f"Betting prediction saved to history file.")
        return True
    except Exception as e:
        print(f"Error saving betting prediction: {e}")
    
    return False

def create_player_playoff_url(first_name, last_name, season=None):
    """
    Create the correct Basketball Reference URL for a player's playoff data.
    Format: first letter of last name/first 5 letters of last name + first 2 letters of first name
    Example: Stephen Curry -> c/curryst01/gamelog-playoffs/
    """
    # Format names correctly
    first_name = first_name.strip().lower()
    last_name = last_name.strip().lower()
   
    # Create the initial part of the player ID
    first_letter = last_name[0]
    last_name_part = last_name[:5]
    first_name_part = first_name[:2]
   
    # Construct base URL pattern
    player_id = f"{last_name_part}{first_name_part}01"
   
    # If season is specified, add it to the URL
    if season:
        base_url = f"https://www.basketball-reference.com/players/{first_letter}/{player_id}/gamelog-playoffs/{season}"
    else:
        base_url = f"https://www.basketball-reference.com/players/{first_letter}/{player_id}/gamelog-playoffs/#player_game_log_post"
   
    # Check if this URL exists
    try:
        response = requests.get(base_url)
        if response.status_code == 200:
            return base_url, player_id
       
        # If not found, we should search more systematically
        print(f"Player page not found. Attempted URL: {base_url}")
        print("The player ID might have a different sequence number or format.")
        return None, None
    except Exception as e:
        print(f"Error accessing URL: {e}")
        return None, None

def get_playoff_games(player_url):
    """Fetches and returns all available playoff games of a player."""
    try:
        # Get the HTML content
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
        response = requests.get(player_url, headers=headers)
       
        # Check if response is successful
        if response.status_code != 200:
            print(f"Failed to access {player_url}, status code: {response.status_code}")
            return None
           
        soup = BeautifulSoup(response.content, 'html.parser')
       
        # Find all playoff tables
        playoff_tables = []
       
        # Check for tables with different possible ID patterns
        table_patterns = [
            re.compile(r'pgl_basic_playoffs'),  # Standard pattern
            re.compile(r'playoffs_.*'),         # Alternative pattern
            re.compile(r'post_.*')              # Another possible pattern
        ]
       
        for pattern in table_patterns:
            tables = soup.find_all('table', id=pattern)
            if tables:
                playoff_tables.extend(tables)
       
        # If no tables found with IDs, try looking for tables with specific class names
        if not playoff_tables:
            # Look for tables that might contain playoff data
            for table in soup.find_all('table'):
                # Look for headers or captions that indicate playoff data
                caption = table.find('caption')
                if caption and ('playoff' in caption.text.lower() or 'post' in caption.text.lower()):
                    playoff_tables.append(table)
               
                # Check for playoff indicators in table classes or attributes
                if table.has_attr('class') and any('playoff' in c.lower() for c in table['class']):
                    playoff_tables.append(table)
       
        # Last resort: if still no tables found, try to find any div containing playoff data
        if not playoff_tables:
            playoff_divs = soup.find_all('div', id=re.compile(r'div_playoffs'))
            for div in playoff_divs:
                tables = div.find_all('table')
                playoff_tables.extend(tables)
       
        if not playoff_tables:
            print(f"No playoff tables found at {player_url}")
            # Try to determine if this is due to no playoff appearances or website structure issue
            if "Playoffs" not in soup.text and "playoff" not in soup.text.lower():
                print("Player may not have playoff appearances.")
            else:
                print("Tables exist but could not be properly accessed. Website structure may have changed.")
            return None
       
        # Process all tables
        all_playoff_data = []
        for table in playoff_tables:
            # Convert HTML table to DataFrame - use StringIO to avoid FutureWarning
            html = str(table)
            try:
                dfs = pd.read_html(StringIO(html))
                if not dfs:
                    continue
                df = dfs[0].copy()  # Create a copy to avoid SettingWithCopyWarning
               
                # Clean the DataFrame - remove header rows and summary rows
                if 'Rk' in df.columns:
                    # Filter out header repetitions and summary rows (TOT)
                    df = df[~df['Rk'].isin(['Rk', 'TOT'])].copy()
                    # Convert 'Rk' to numeric to further filter out non-numeric values
                    df['Rk'] = pd.to_numeric(df['Rk'], errors='coerce')
                    df = df[df['Rk'].notna()].copy()
               
                # Extract season information
                season = "Unknown"
                if table.get('id'):
                    season_match = re.search(r'playoffs_(\d+)', table.get('id', ''))
                    if season_match:
                        season = season_match.group(1)
                else:
                    # Try to extract season from nearby elements
                    for element in table.previous_siblings:
                        if hasattr(element, 'text') and re.search(r'20\d{2}-\d{2}', element.text):
                            season_match = re.search(r'20\d{2}-\d{2}', element.text)
                            if season_match:
                                season = season_match.group(0)
                                break
               
                # Add series information based on patterns in data (use .loc to avoid SettingWithCopyWarning)
                if 'Opp' in df.columns:
                    df.loc[:, 'Series'] = df['Opp'].apply(lambda x: x if pd.notna(x) else '')
                else:
                    df.loc[:, 'Series'] = ''
                   
                # Add Game_In_Series - check if 'G' or 'Gm' or 'Game' column exists
                game_col = None
                for possible_col in ['Gm', 'G', 'Game', '#']:
                    if possible_col in df.columns:
                        game_col = possible_col
                        break
                       
                if game_col:
                    df.loc[:, 'Game_In_Series'] = df[game_col].apply(
                        lambda x: int(x) if pd.notna(x) and str(x).isdigit() else 0)
                else:
                    df.loc[:, 'Game_In_Series'] = 0
               
                # Ensure we have a 'Gm' column to avoid KeyError later
                if 'Gm' not in df.columns:
                    if game_col:
                        df.loc[:, 'Gm'] = df[game_col]
                    else:
                        df.loc[:, 'Gm'] = df['Game_In_Series']
               
                # Add the season information
                df.loc[:, 'Season'] = season
               
                # Make sure required columns exist
                required_cols = ['PTS', 'AST', 'TRB', 'MP', 'Date', 'Opp', 'Result']
                for col in required_cols:
                    if col not in df.columns:
                        if col == 'PTS' and 'PT' in df.columns:  # Some tables use PT instead of PTS
                            df.loc[:, 'PTS'] = df['PT']
                        elif col == 'TRB' and 'REB' in df.columns:  # Some tables use REB instead of TRB
                            df.loc[:, 'TRB'] = df['REB']
                        else:
                            df.loc[:, col] = np.nan
               
                all_playoff_data.append(df)
               
            except Exception as e:
                print(f"Error processing table: {e}")
                continue
       
        # Combine all tables
        if all_playoff_data:
            combined_df = pd.concat(all_playoff_data, ignore_index=True)
           
            # Additional filtering for summary rows that might have slipped through
            if 'Rk' in combined_df.columns:
                # Convert Rk to numeric and filter out non-numeric values
                combined_df['Rk'] = pd.to_numeric(combined_df['Rk'], errors='coerce')
                combined_df = combined_df[combined_df['Rk'].notna()].copy()
           
            # Filter out rows that might contain "Totals" in any column
            for col in combined_df.columns:
                if combined_df[col].dtype == 'object':
                    combined_df = combined_df[~combined_df[col].astype(str).str.contains('Total', case=False, na=False)].copy()
           
            # Convert date to datetime
            combined_df['Date'] = pd.to_datetime(combined_df['Date'], errors='coerce')
           
            # Ensure numeric conversion for key stats
            numeric_cols = ['PTS', 'AST', 'TRB', 'MP', 'FG', 'FGA', '3P', '3PA', '2P', '2PA', 'FT', 'FTA',
                           'ORB', 'DRB', 'STL', 'BLK', 'TOV', 'PF', '+/-']
            for col in numeric_cols:
                if col in combined_df.columns:
                    combined_df[col] = pd.to_numeric(combined_df[col], errors='coerce')
           
            # Add PRA (Points + Rebounds + Assists)
            if all(col in combined_df.columns for col in ['PTS', 'AST', 'TRB']):
                combined_df.loc[:, 'PRA'] = combined_df['PTS'] + combined_df['AST'] + combined_df['TRB']
           
            # Sort by date descending (most recent first)
            combined_df = combined_df.sort_values(by='Date', ascending=False)
           
            return combined_df
        else:
            print(f"No playoff data found for player at {player_url}")
            return None
    except Exception as e:
        print(f"Error fetching playoff data from {player_url}: {e}")
        return None

def extract_series_info(df):
    """Extract playoff series information from the dataframe."""
    if df is None or df.empty:
        return None
   
    # Make a copy to avoid modifying the original
    series_df = df.copy()
   
    # Filter out summary rows which can inflate statistics
    if 'Rk' in series_df.columns:
        # Convert to numeric and filter out non-numeric values (like 'Rk', 'TOT')
        series_df['Rk'] = pd.to_numeric(series_df['Rk'], errors='coerce')
        series_df = series_df[series_df['Rk'].notna()].copy()
   
    # Extract series information - handling potential missing columns
    def create_series_info(row):
        season = row['Season'] if 'Season' in row and pd.notna(row['Season']) else 'Unknown'
        opponent = row['Opp'] if 'Opp' in row and pd.notna(row['Opp']) else 'Unknown'
        game = row['Gm'] if 'Gm' in row and pd.notna(row['Gm']) else (
               row['Game_In_Series'] if 'Game_In_Series' in row and pd.notna(row['Game_In_Series']) else 'Unknown')
       
        return f"{season} - {opponent} - Game {game}"
   
    # Apply the function safely
    series_df.loc[:, 'Series_Info'] = series_df.apply(create_series_info, axis=1)
   
    # Group by opponent and season to identify different series
    def create_series_id(row):
        season = row['Season'] if 'Season' in row and pd.notna(row['Season']) else 'Unknown'
        opponent = row['Opp'] if 'Opp' in row and pd.notna(row['Opp']) else 'Unknown'
        return f"{season}_{opponent}"
   
    series_df.loc[:, 'Series_ID'] = series_df.apply(create_series_id, axis=1)
   
    return series_df

def get_games_vs_team(df, team_abbr):
    """Filter games against a specific team."""
    if df is None or df.empty:
        return None
   
    # Filter games against the team
    team_games = df[df['Opp'].str.contains(team_abbr, na=False)].copy()
   
    return team_games

def calculate_playoff_stats(df, team_abbr=None):
    """Calculate playoff statistics for a player."""
    if df is None or df.empty:
        print("No playoff data available.")
        return None, None, None
   
    # Make a clean copy of the dataframe
    df_clean = df.copy()
   
    # Filter out summary rows to avoid inflating averages
    if 'Rk' in df_clean.columns:
        # Convert Rk to numeric and filter out non-numeric values (like 'Rk', 'TOT')
        df_clean['Rk'] = pd.to_numeric(df_clean['Rk'], errors='coerce')
        df_clean = df_clean[df_clean['Rk'].notna()].copy()
   
    # Additional filtering for 'Total' rows that might inflate stats
    for col in df_clean.columns:
        if df_clean[col].dtype == 'object':
            df_clean = df_clean[~df_clean[col].astype(str).str.contains('Total', case=False, na=False)].copy()
   
    # Add series context information
    series_df = extract_series_info(df_clean)
   
    # Make sure PTS, AST, TRB are numeric
    for col in ['PTS', 'AST', 'TRB']:
        if col in series_df.columns:
            series_df[col] = pd.to_numeric(series_df[col], errors='coerce')
   
    # Calculate overall playoff averages - only include rows with valid points data
    valid_data = series_df[series_df['PTS'].notna()].copy()
   
    playoff_avg = {
        'PTS': valid_data['PTS'].mean() if not valid_data.empty else np.nan,
        'AST': valid_data['AST'].mean() if not valid_data.empty else np.nan,
        'TRB': valid_data['TRB'].mean() if not valid_data.empty else np.nan,
        'PRA': valid_data['PRA'].mean() if 'PRA' in valid_data.columns and not valid_data.empty else np.nan
    }
   
    # Calculate standard deviations
    playoff_std = {
        'PTS': valid_data['PTS'].std() if not valid_data.empty else np.nan,
        'AST': valid_data['AST'].std() if not valid_data.empty else np.nan,
        'TRB': valid_data['TRB'].std() if not valid_data.empty else np.nan,
        'PRA': valid_data['PRA'].std() if 'PRA' in valid_data.columns and not valid_data.empty else np.nan
    }
   
    # Get last 10 playoff games - make sure they're valid games with stats
    last_10_games = valid_data.head(10)
   
    # Calculate last 10 games averages
    last_10_avg = {
        'PTS': last_10_games['PTS'].mean() if not last_10_games.empty else np.nan,
        'AST': last_10_games['AST'].mean() if not last_10_games.empty else np.nan,
        'TRB': last_10_games['TRB'].mean() if not last_10_games.empty else np.nan,
        'PRA': last_10_games['PRA'].mean() if 'PRA' in last_10_games.columns and not last_10_games.empty else np.nan
    }
   
    # Last 10 games standard deviation
    last_10_std = {
        'PTS': last_10_games['PTS'].std() if not last_10_games.empty else np.nan,
        'AST': last_10_games['AST'].std() if not last_10_games.empty else np.nan,
        'TRB': last_10_games['TRB'].std() if not last_10_games.empty else np.nan,
        'PRA': last_10_games['PRA'].std() if 'PRA' in last_10_games.columns and not last_10_games.empty else np.nan
    }
   
    # If team is specified, calculate stats against that team
    if team_abbr:
        team_games = get_games_vs_team(valid_data, team_abbr)
       
        if team_games is not None and not team_games.empty:
            team_avg = {
                'PTS': team_games['PTS'].mean(),
                'AST': team_games['AST'].mean(),
                'TRB': team_games['TRB'].mean(),
                'PRA': team_games['PRA'].mean() if 'PRA' in team_games.columns else np.nan
            }
           
            team_std = {
                'PTS': team_games['PTS'].std(),
                'AST': team_games['AST'].std(),
                'TRB': team_games['TRB'].std(),
                'PRA': team_games['PRA'].std() if 'PRA' in team_games.columns else np.nan
            }
        else:
            team_avg = {stat: float('nan') for stat in ['PTS', 'AST', 'TRB', 'PRA']}
            team_std = {stat: float('nan') for stat in ['PTS', 'AST', 'TRB', 'PRA']}
    else:
        team_avg = {stat: float('nan') for stat in ['PTS', 'AST', 'TRB', 'PRA']}
        team_std = {stat: float('nan') for stat in ['PTS', 'AST', 'TRB', 'PRA']}
   
    # Create DataFrames for summary display
    stats_df = pd.DataFrame({
        'Stat': ['PTS', 'AST', 'TRB', 'PRA'],
        'Playoff Career Avg': [playoff_avg['PTS'], playoff_avg['AST'], playoff_avg['TRB'], playoff_avg['PRA']],
        'Last 10 Playoff Games Avg': [last_10_avg['PTS'], last_10_avg['AST'], last_10_avg['TRB'], last_10_avg['PRA']],
        f'Vs {team_abbr} Playoff Avg': [team_avg['PTS'], team_avg['AST'], team_avg['TRB'], team_avg['PRA']]
    })
   
    std_df = pd.DataFrame({
        'Stat': ['PTS', 'AST', 'TRB', 'PRA'],
        'Playoff Career StdDev': [playoff_std['PTS'], playoff_std['AST'], playoff_std['TRB'], playoff_std['PRA']],
        'Last 10 Playoff Games StdDev': [last_10_std['PTS'], last_10_std['AST'], last_10_std['TRB'], last_10_std['PRA']],
        f'Vs {team_abbr} Playoff StdDev': [team_std['PTS'], team_std['AST'], team_std['TRB'], team_std['PRA']]
    })
   
    # Round for cleaner display
    for col in stats_df.columns[1:]:
        stats_df[col] = stats_df[col].round(1)
    for col in std_df.columns[1:]:
        std_df[col] = std_df[col].round(1)
   
    return stats_df, std_df, valid_data

def calculate_betting_probability(stat_values, line_value, mean=None, std=None):
    """
    Calculate the probability of a player exceeding a betting line.
    Uses a combination of normal distribution and historical frequency.
    """
    # Remove NaN values
    stat_values = stat_values.dropna()
    if len(stat_values) < 3:
        return None, None, None, None
   
    # Calculate mean and standard deviation if not provided
    if mean is None:
        mean = stat_values.mean()
    if std is None:
        std = stat_values.std()
   
    # Calculate historical frequency
    historical_freq = (stat_values > line_value).mean()
   
    # Calculate probability using normal distribution
    if std > 0:  # Avoid division by zero
        z_score = (line_value - mean) / std
        prob_over = 1 - stats.norm.cdf(z_score)
    else:
        # If std is 0, all values are the same
        prob_over = 1.0 if mean > line_value else 0.0
   
    return prob_over, historical_freq, mean, std

def display_betting_history(first_name, last_name, team_abbr=None):
    """Display previous betting predictions and outcomes for this player."""
    history = load_betting_history(first_name, last_name)
    if not history:
        print("No betting history found for this player.")
        return
    
    # Filter by team if specified
    if team_abbr:
        team_history = [entry for entry in history if entry.get("opponent") == team_abbr]
        if not team_history:
            print(f"No betting history found against {team_abbr}.")
            # Show all teams in history
            teams = set(entry.get("opponent") for entry in history)
            print(f"History exists for games against: {', '.join(teams)}")
            return
        history = team_history
    
    print("\n" + "="*50)
    print(f"BETTING HISTORY FOR {first_name.upper()} {last_name.upper()}")
    if team_abbr:
        print(f"Against {team_abbr}")
    print("="*50)
    
    # Display most recent predictions first
    history.reverse()
    
    for i, entry in enumerate(history):
        print(f"\nDate: {entry['date']} - Opponent: {entry['opponent']}")
        print("-" * 40)
        
        for line in entry["lines"]:
            result_str = ""
            if line.get("actual_result") is not None:
                result = "WIN" if (line["actual_result"] > line["line"] and line["probability"] > 0.5) or \
                                  (line["actual_result"] < line["line"] and line["probability"] < 0.5) else "LOSS"
                result_str = f" -> ACTUAL: {line['actual_result']} ({result})"
            
            print(f"{line['stat']} > {line['line']}: {line['recommendation']}{result_str}")
        
        # Only show last 3 entries to keep it clean
        if i >= 2 and len(history) > 3 and not team_abbr:
            remaining = len(history) - 3
            print(f"\n... and {remaining} more entries. Use team filter to see specific matchups.")
            break

def record_bet_outcome(first_name, last_name):
    """Record the actual outcomes of previous bets."""
    history = load_betting_history(first_name, last_name)
    if not history:
        print("No betting history found for this player.")
        return
    
    # Find most recent prediction without recorded outcome
    recent_predictions = [p for p in history if not p.get("outcome_recorded")]
    if not recent_predictions:
        print("No pending predictions found. All outcomes have been recorded.")
        return
    
    recent = recent_predictions[-1]  # Get most recent
    print(f"\nRecord outcome for prediction from {recent['date']} against {recent['opponent']}:")
    
    # Update each betting line with actual result
    for i, line in enumerate(recent["lines"]):
        print(f"{i+1}. {line['stat']} > {line['line']} ({line['recommendation']})")
        result = input(f"   Enter actual {line['stat']} value (leave blank to skip): ")
        if result.strip():
            try:
                recent["lines"][i]["actual_result"] = float(result)
            except ValueError:
                print("Invalid input. Skipping.")
    
    # Mark as recorded
    recent["outcome_recorded"] = True
    
    # Save updated history
    filename = get_player_betting_history_filename(first_name, last_name)
    try:
        with open(filename, 'w') as f:
            json.dump(history, f, indent=2)
        print("Bet outcomes recorded successfully!")
    except Exception as e:
        print(f"Error saving outcomes: {e}")

# Completing the analyze_playoff_betting_lines function and adding required functionality

def analyze_playoff_betting_lines(player_name, team_abbr, stats_df, std_df, all_games, team_games=None):
    """Analyze betting lines for playoffs with special weight on playoff context."""
    print("\n" + "="*50)
    print(f"PLAYOFF BETTING LINE ANALYSIS FOR {player_name} vs {team_abbr}")
    print("="*50)
   
    # Split player name
    name_parts = player_name.split()
    first_name = name_parts[0]
    last_name = name_parts[-1]
    
    # Check betting history for prefilled lines
    history = load_betting_history(first_name, last_name)
    latest_lines = {}
    
    if history:
        # Check if there are previous lines against this team
        team_entries = [entry for entry in history if entry.get("opponent") == team_abbr]
        if team_entries:
            latest_team_entry = team_entries[-1]
            print(f"\nFound previous lines from {latest_team_entry['date']} against {team_abbr}:")
            for line in latest_team_entry["lines"]:
                print(f"{line['stat']}: {line['line']} ({line['recommendation']})")
            
            use_previous = input("\nUse these lines as starting point? (y/n): ").lower().strip()
            if use_previous == 'y':
                for line in latest_team_entry["lines"]:
                    latest_lines[line['stat']] = line['line']
    
    all_stats = ['PTS', 'AST', 'TRB', 'PRA']
    betting_lines = {}
   
    # Prompt for betting lines, using historical values as defaults
    print("\nEnter playoff betting lines (leave blank to skip):")
    for stat in all_stats:
        default = f" [{latest_lines.get(stat)}]" if stat in latest_lines else ""
        line_input = input(f"{stat} line{default}: ")
        
        # Use default if nothing entered
        if not line_input and stat in latest_lines:
            betting_lines[stat] = latest_lines[stat]
        elif line_input:
            try:
                betting_lines[stat] = float(line_input)
            except ValueError:
                print(f"Invalid value for {stat} line. Skipping.")
    
    if not betting_lines:
        print("No valid betting lines entered.")
        return None
    
    # Calculate probabilities and make recommendations
    results = []
    
    print("\n" + "-"*50)
    print("BETTING ANALYSIS RESULTS")
    print("-"*50)
    
    for stat, line in betting_lines.items():
        # Get the row for this stat
        stat_row = stats_df[stats_df['Stat'] == stat].iloc[0]
        std_row = std_df[std_df['Stat'] == stat].iloc[0]
        
        # Get values for different scenarios
        career_avg = stat_row['Playoff Career Avg']
        career_std = std_row['Playoff Career StdDev']
        last_10_avg = stat_row['Last 10 Playoff Games Avg']
        last_10_std = std_row['Last 10 Playoff Games StdDev']
        
        vs_team_avg = stat_row[f'Vs {team_abbr} Playoff Avg']
        vs_team_std = std_row[f'Vs {team_abbr} Playoff StdDev']
        
        # Calculate probabilities for different datasets
        stat_values = all_games[stat].dropna() if stat in all_games.columns else pd.Series([])
        
        # If team_games exists and contains data for this stat, use it
        team_stat_values = None
        if team_games is not None and not team_games.empty and stat in team_games.columns:
            team_stat_values = team_games[stat].dropna()
        
        # Calculate overall playoff probability
        career_prob, career_freq, _, _ = calculate_betting_probability(
            stat_values, line, mean=career_avg, std=career_std)
        
        # Calculate probability based on last 10 games
        last_10_values = all_games.head(10)[stat].dropna() if stat in all_games.columns else pd.Series([])
        recent_prob, recent_freq, _, _ = calculate_betting_probability(
            last_10_values, line, mean=last_10_avg, std=last_10_std)
        
        # Calculate probability based on games vs this team
        team_prob, team_freq, _, _ = calculate_betting_probability(
            team_stat_values if team_stat_values is not None else pd.Series([]), 
            line, mean=vs_team_avg, std=vs_team_std)
        
        # Weighted probability calculation
        weights = {
            'career': 0.3,
            'recent': 0.4,
            'team': 0.3
        }
        
        # Adjust weights if some data isn't available
        if pd.isna(team_prob) or team_prob is None:
            weights['career'] += weights['team'] / 2
            weights['recent'] += weights['team'] / 2
            weights['team'] = 0
            
        if pd.isna(recent_prob) or recent_prob is None:
            weights['career'] += weights['recent']
            weights['recent'] = 0
        
        # Calculate weighted probability
        weighted_prob = 0
        if career_prob is not None:
            weighted_prob += career_prob * weights['career']
        if recent_prob is not None:
            weighted_prob += recent_prob * weights['recent']
        if team_prob is not None:
            weighted_prob += team_prob * weights['team']
            
        # Make recommendation
        if weighted_prob > 0.65:
            recommendation = f"STRONG BET OVER ({weighted_prob:.1%})"
        elif weighted_prob > 0.55:
            recommendation = f"LEAN OVER ({weighted_prob:.1%})"
        elif weighted_prob < 0.35:
            recommendation = f"STRONG BET UNDER ({weighted_prob:.1%})"
        elif weighted_prob < 0.45:
            recommendation = f"LEAN UNDER ({weighted_prob:.1%})"
        else:
            recommendation = f"AVOID ({weighted_prob:.1%})"
            
        # Store results
        result = {
            "Stat": stat,
            "Line": line,
            "Probability": round(weighted_prob, 3),
            "Recommendation": recommendation,
            "Career_Prob": round(career_prob, 3) if career_prob is not None else None,
            "Recent_Prob": round(recent_prob, 3) if recent_prob is not None else None,
            "Team_Prob": round(team_prob, 3) if team_prob is not None else None
        }
        results.append(result)
        
        # Display results
        print(f"\n{stat} Line: {line}")
        print(f"Career Avg: {career_avg:.1f} (StdDev: {career_std:.1f}) - Prob Over: {career_prob:.1%} if available")
        print(f"Last 10 Avg: {last_10_avg:.1f} (StdDev: {last_10_std:.1f}) - Prob Over: {recent_prob:.1%} if available")
        print(f"Vs {team_abbr} Avg: {vs_team_avg:.1f} (StdDev: {vs_team_std:.1f}) - Prob Over: {team_prob:.1%} if available")
        print(f"Weighted Probability: {weighted_prob:.1%}")
        print(f"Recommendation: {recommendation}")
        
    # Save betting prediction to history file
    if results:
        save_betting_prediction(first_name, last_name, team_abbr, results)
        
    return results

def main():
    """Main function to run the playoff betting predictor."""
    print("\n" + "="*60)
    print("NBA PLAYOFF PLAYER PERFORMANCE PREDICTOR".center(60))
    print("="*60)
    
    # Get player name
    player_name = input("\nEnter player name (First Last): ")
    if not player_name.strip():
        print("Player name is required.")
        return
    
    # Split name into first and last
    name_parts = player_name.split()
    if len(name_parts) < 2:
        print("Please enter both first and last name.")
        return
    
    first_name = name_parts[0]
    last_name = name_parts[-1]
    
    # Check for existing data
    existing_data = check_existing_data(first_name, last_name)
    
    if existing_data is not None:
        print(f"Found existing playoff data for {player_name}!")
        use_existing = input("Use existing data? (y/n): ").lower().strip()
        if use_existing == 'y':
            playoff_data = existing_data
        else:
            # Fetch new data
            player_url, player_id = create_player_playoff_url(first_name, last_name)
            if player_url:
                print(f"Fetching playoff data for {player_name}...")
                playoff_data = get_playoff_games(player_url)
                if playoff_data is not None:
                    save_player_data(first_name, last_name, playoff_data)
            else:
                print(f"Could not create URL for {player_name}.")
                return
    else:
        # No existing data, fetch new data
        player_url, player_id = create_player_playoff_url(first_name, last_name)
        if player_url:
            print(f"Fetching playoff data for {player_name}...")
            playoff_data = get_playoff_games(player_url)
            if playoff_data is not None:
                save_player_data(first_name, last_name, playoff_data)
        else:
            print(f"Could not create URL for {player_name}.")
            return
    
    if playoff_data is None or playoff_data.empty:
        print(f"No playoff data found for {player_name}.")
        return
        
    # User options
    print("\nOptions:")
    print("1. Analyze betting lines vs specific team")
    print("2. Display betting history")
    print("3. Record bet outcome")
    
    option = input("Select option (1-3): ")
    
    if option == '1':
        # Get opponent team
        team_abbr = input("\nEnter opponent team abbreviation (e.g., BOS, LAL): ").upper()
        if not team_abbr.strip():
            print("Team abbreviation is required.")
            return
            
        # Calculate player stats
        stats_df, std_df, all_games = calculate_playoff_stats(playoff_data, team_abbr)
        
        # Get games vs team
        team_games = get_games_vs_team(all_games, team_abbr)
        
        # Analyze betting lines
        analyze_playoff_betting_lines(player_name, team_abbr, stats_df, std_df, all_games, team_games)
        
    elif option == '2':
        # Display betting history
        team_abbr = input("\nEnter team abbreviation to filter (leave blank for all): ").upper().strip()
        display_betting_history(first_name, last_name, team_abbr if team_abbr else None)
        
    elif option == '3':
        # Record bet outcome
        record_bet_outcome(first_name, last_name)
        
    else:
        print("Invalid option.")

if __name__ == "__main__":
    main()
